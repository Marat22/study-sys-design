# Chapter 1
- faults != fails. fail - полная остановка, fault - ошибка в одном компненте.
- Основные типы faults
  - Hardware faults
    - причины:
      - периодически состовляющие компьютеров выходят из строя
    - решение:
      - изначально разрабатывать систему так, чтобы поломка одной машины не мешала работе системы в целом
    - дублирование компонентов машины
      - 1 запасной источник питание
      - запасное CPU
      - запасной жёсткий диск
  - Software Error
    - причины:
      - ошибка в программе
    - проблемы:
      - ошибка в одном компоненте может повлиять на ошибки в других компонентах
      - каскадные ошибки. Один компонент не работает -> остальные тоже перестают
      - подобные проблемы выясняются обычно не сразу. Программа может несколько лет проработать без проблем, но при стечении определённых обстоятельств рухнуть.
      - тяжело найти причину
    - решение:
      - нет конкретного решения, но некоторые практики позволяют снизить риск такой ошибки:
        - юнит тестирование
        - тестирование системы целиком
        - изоляция процессов
        - анализ системы в процессе работы
        - программа может сама проверять свою работу
  - Human Errors
    - причины:
      - человеческий фактор
    - решение:
      - Уменьшить возможности для ошибки. Например, продуманное API, абстракция, админ панель
      - Декаплить (decouple) системы, где велика вероятность человеческой ошибки, от систем, которым ошибка может навредить
      - Тестирование юнитов и всей системы в целом
      - Возможность быстро откатить ошибки
      - Мониторинг

Разница между latency (задержка) и response time (время ответа):
- в `response time` входит всё время, начиная с отправки запроса и заканчивая получение ответа
- `latency` это время, в течение которого запрос ждёт, чтобы его обработали. 

response time этто не конкретная величина, а целый набор величин для измерения. 


Обычно для анализа response time сначала создаётся отсортированный список со временем всех запросов. А затем находится percentile:
- допустим, статистика response time = [1, 1, 2, 5, 11]
- возьмём percentile 50 (p50) - 2
- это значит, что в 50% response time меньше 2 секунд, а остальные 50% больше 2 секунд
- если взять percentile 80, то получем 5
- это значит, что в 80% response time меньше 5 секунд, но в остальных 20% response time больше 5 секунд

- SLA задаёт минимум для response time и других параметров работы сервиса. Если SLA нарушается, то клиент может потребовать возврата денег. Например, p50 должен быть <= 0.2, p999 (99.9) <= 1.
- Важно замерять response time на стороне клиента, потому что на response time может влиять Queueing delays (время, которое требуется пакету для передачи через сеть). Помимо этого может происходить head-of-line blocking.
- При тестировании системы важно отправлять запросы, не дожидаясь ответа на предыдущей, чтобы тестирование было более приближенно к реальности.

- Если действие пользователя включает в себя много запросов к бекенду, то важно помнить, что итоговое время во много определяется самым долгим запросом. Если 5 запросов заняли 0.01 секунду, но последний запрос занял 2 секунды, то действие будет выполняться медленно. Это называется `Tail latency amplification`.
- Если требуется отслеживать percintile по response time, то стоит использовать специальные алгоритмы (forward decay, t-digest, HdrHistogram), потому что каждый раз заново сортировать список всех response time - это неэффективно.

- scaling up = vertical scaling = shared nothing architecture = moving to more powerful machine.
- scaling out = horizontal scaling = distributing the load across multiple smaller machines.
- существуют `elastic` системы, которые автоматически добавляют ресурсы компьютера при большой нагрузке. Подобные системы полезны в тех случаях, если нагрузка непредсказуема. Однако увелечение ресурсов системы гораздо проще и меньше вероятность сюрпризов.

- гораздо проще заниматься scaling'ом stateless систем

# Chapter 8: The Trouble With Distributed Systems
- Всё, что может пойти не так, пойдёт не так.
- В этой главе рассказывается о возможных проблемах распределённых систем.

## Faults and Partial Failures
- Если программа пишется для запуска на одном компьютере, то всё просто. Если программа написана правильно, то всё будет работать правильно. Если в работе машины произошла ошибка, то она падает полностью. Если в CPU передать одни входные данные, то всегда получешь тот же выход. **Всё просто!**
- Однако в распределённых системах всё гораздо сложнее. 
Может произойти `partial failure`, когда не работает только один компонент, но в целом система работает нормально. 
- Проблема с `partial failure` заключается в том, что он `non-deterministic`: т.е. иногда запускаешь несколько нодов и всё работает правильно, а иногда неожиданно всё падает. 
- `partial failure` и `non-determinism` - основные проблемы при работе с распределёнными системами

### Network congestion and queueing
Зачастую задержки доставки пакетов происходят из-за очередей:
- Если множество нодов отправляют запрос на один нод, то может произоайти переполнение очереди. В таком случае запросы начинают просто отбрасываться, несмотря на то, что сеть в целом работает исправно
- Если все CPU cores (ядра процессора?) заняты, то ОС помещает запрос в очередь. Время нахождения в этой очереди может продолжаться произвольное количество времени.
- Если на машине запущено несколько виртуальных машин, то ОС может быть остановлена на примерно 10 милисекунд, пока другая ВМ использует CPU core (ядро процессора?)
- TCP занимается `flow control` (управление потоком, также называется: congestion avoidance и backpressure), чтобы не перегрузить нод получателя или линию сети. Это значит, что дополнительное создание очередей происходит даже в отправителе.

После определённого времени после отправки пакета TCP считает его утерянным и начинает его отправить снова и снова. Т.к. это происходит на уровне TCP, то приложение не замечает этих переотправок, но зато замечает задержку в отправке пакета. 

UDP
- UDP - хороший баланс между надежностью в тех случаях, когда не страшно недополучить/недоотправить часть пакетов.
- UDP не занимается `flow control`
- Не занимается переотправкой потерянных пакетов
- UDP позволяет избегать многих причин, по которым могут происходить задежки отправки пакетов.
- хорошо подходит для аудио/видео созвонов

определить оптимальный timeout можно только экспериментаальным путём. В идеале лучше использовать механизм для автоматического определения оптимального `timeout` в зависимости от текущего распределения времени ответов.

## Synchronous vs. Asynchronous Networks


## Unreliable Clocks
Часы и время ккрайне важная вещь для распределённых систем. Они позволяют ответить на вопросы:
- Прошёл ли timeout для запроса?
- Какая 99-ая процентиль для `response time`
- Сколько времени пользователь провёл на нашем сайте
....

Есть специальный механизм для синхронизации времени между машинами - `NTP`

### Monotonic vs Time-of-Day Clocks
В компьютере есть 2 типа времени:
- monotonic 
  - позволяет точно высчитать `elapsed time`, время выполнения программы, функции, запроса...
  - никогда не может пойти в обратную сторону
  - обычно отсчитывается от начала запуска копмьютера
  - **ОДНАКО**, если в компе несколько CPU, то monolitic time этих CPU могут быть не синхронизированы. Для запущенных приложений ОС старается синхронизировать эти CPU времена, однако не нужно на это надеятся слишком много.
- time-of-day
  - выглдяит как обычные время, которым мы пользуемся в жизни
  - обычно отсчитывается от эпохи (напр. 1 января 1970 года)
  - синхронизируется с помощью `NTP`
  - может уменьшиться (например, при изменении часового пояса)
  - на time-of-day влияют `leap seconds`

`leap seconds` - дополнительные секунды, которые добавляются в июня или декабря. За счёт них время совпадает с фактическим вращением Земли.
- когда добавляется `leap second`, то между 23:59:59 и 00:00:00 добавляется 23:59:60
- если это не учитывать, то система может рухнуть

### Clock Synchronization and Accuracy
- Кварцовые часы являются некорректными, они `drifts` (спешат или отстают).
- NTP сервер может выдавать некорректное время, поэтому важно запрашивать время с нескольких серверов не учитывать выбросы
- Если время компьютера слишком отличается от времени NTP сервера, то он может отказать в синхронизации или принудительно сбросить время компа.

### Relying on Synchronized Clocks
- Нельзя полностью полагаться, что time-of-day часы работают корректно
- Нужно мониторить, что у всех нодов одинаковое время. Нод, у которого время сильно отличается от остальных, должен считаться мёртвым.

`pitfalls` - подводные камни.


## Knowledge, Truth, and Lies
### System models and Reality
Существует множество алгоритмов для решения проблем распределённых систем. Чтобы алгоритмы подходили под множество систем, нужно создать абстрактные system models, в которых описаны те вещи, на которые может полагаться алгоритм.

В плане сроков существует 3 system models:
- Synchronous model
  - **модель нереалистична**
  - время delay'а ограничено
  - паузы при работе процесса ограничены
  - ограничена ошибка часов
- Partially synchronous model
  - **самая реальная модель**
  - большую часть времени ведёт себя как synchronous model 
  - однако нет ограничений у delay
  - нет ограничений по времени пауз процессов
  - нет ограничений по ошибке часов
- Asynchronous model
  - **встречается редко**
  - В такой моделе нельзя делать никаких предположений по времени.
  - нету часов 

В плане node failures существует 3 наиболее частых system models:
- Crash-stop faults
  - **нереалистичная модель**
  - В этой модели нод может fail только by crashing 
- Crash-recovery faults
  - **реалистичная модель**
  - В этой модели нод может crash в любой момент и возможно снова начать отвечать через какое-то время.
- Byzantine (arbitrary) faults
  - **встречается редко**
  - Ноды могут делать абсолютно что угодно, даже пытаться обмануть другие ноды

### Correctness of an algorithm
Чтобы определить, что алгоритм корректен, нужно описать его свойства (`properties`).

Например, для [fencing tokens](#fencing-tokens) свойства могли бы быть следующие:
- Uniqueness
  - Токены не должны повторяться
- Monotonic sequence
  - Каждый новый токен должен быть больше предыдущего
- Availablity
  - Нод, который запрашивает токен получает ответ (если нод не крашнулся)

**Алгоритм корректен, если:**
- В system model, которая всегда удовлетворяет все свойства (`properties`) во всех ситуациях, которые могут произойти в этой system model.

### Safety and liveness
Есть 2 типа свойств (`properties`):
- liveness
  - something good eventually happens
  - В предыдущем примере Availability - liveness свойство
  - Другой пример - `Eventual consistency`
  - Точное определение: свойство в какой-то момент может не соблюдаться, однако всегда есть надежда на то, что оно в будущем будет выполнено. Например, отправили запрос, но пока не получили ответ.
- safety
  - nothing bad happens
  - в предыдущем примере и Monotonic Sequence и Uniqueness - safety свойства
  - Точное определение: если свойство не соблюдается, то можно назвать конкретный момент, когда оно было нарушено. Нарушения нельзя undone (откатить?). Например, вернулось 2 одинаковых fencing token - нельзя обратить + произошло в конкретный момент.
### Mapping system models to the real world
В реальности всё может быть гораздо сложнее и становится понятно, что sytem model - это просто абстракция реальности, где не учтены все возможные сценарии.

Алгоритмы в crash-recovery model предполагают, что данные в основном носителе не повредятся. Однако, в реальности жёсткий диск может сломаться.

Несмотря на то, что алгоритмы делают определённые допущения о том, что может и не может произойти, при разработке реальных программ важно в коде учитывать ситуации, которые даже предположительно не могут произойти. Хотя бы нужно вывести какое-то предупреждение, чтобы было ясно, что что-то не так.

Тем не менее, теоритический анализ - также важен, как эмпирическое тестирование. Он позволяет узнать о каких-то нюансах, которые могут быть скрыты в течение многих лет работы программы.

## Summary
- Когда отправляешь сообщение по сети, то не можешь быть уверенным в том, что с ним произошло. Дошло ли оно до назначения и потерялось на обратном пути? А может быть это просто delay? А может нод мёртв и больше не принимает сообщения?....
- Время нода может сильно рассинхронизироваться с временем других нодов и временем NTP серверов (которым тоже не всегда можно доверять).
- Процесс может остановиться на значительное время **в абсолютно любой момент**. Может запустить Garbage Collector, остановить программу на минуту, а затем программа продолжит работать, как ни в чём не бывало.  
- Вероятность `partial error` - определяющая характеристика распределённых систем.
- Чтобы обрабатывать faults, нужно их определять, однако даже это нетривиальная задача, потому что зачастую непонятно, где произошла ошибка: в сети или в ноде? А может быть ошибки и не было, но просто сигнал долго идёт. 
  - Поэтому нужно быть осторожным с `timeout-ами`
- Даже если fault найден, то непонятно, как его обрабатывать. Ноды могут принять решение только с помощью quorum, однако для этого им нужно взаимодействовать по ненадёжной сети.
- Многие задачи могут быть достаточно тривиальны и решаться на одном компе.
  - Однако это не решает вопрос low latency и fault tolerane.
